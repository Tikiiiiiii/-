## 001-solution
设数据栈为dataStack，最小栈为minStack
#### 法一：
push(val)规则：
if(dataStack为空) val压入两栈
else if(val < minstack) val压入两栈
其余情况只入栈dataStack

pop规则：
记栈顶为val
if(val == minStack栈顶) 两栈均弹出
// 不存在val < minStack栈顶 

getMin：
只用返回minStack栈顶即可

#### 法二：
该方案和上述的区别在于对push中其余情况的处理
法二在dataStack>= minStack栈顶时，将minStack栈顶值再次入栈minStack

在pop时，同时pop掉minStack即可

两者对比，前者在push花费较少，在pop花费稍多，后者则相反

## 002-solution
利用两个栈模拟，一个作为pushStack，一个作为popStack，前者负责压入，后者负责弹出，并且他们的职能是唯一的不能改变
在设计时为了避免顺序错乱应该保证，popStack不为空时不把pushStack的数据压入popStack否则会数据顺序错误，在pushStack转移到popStack时必须一次性转移

题解未进行错误处理，旨在解算法

## 003-solution
利用递归的方法取得栈中的最后一个元素，即
（1）取出元素进行保存
（2）递归向下取元素
（3）插回元素
再利用递归对取出的元素进行反转
（1）取出元素 （取出顺序1、2、3、4、5）
（2）递归此函数
（3）放回元素   （放回顺序1、2、3、4、5）
对于上述操作的详细过程即
对第1个元素获取   递归    对第1个元素放回
对第1个元素获取   对第2个元素获取   递归   对第2个元素放回   对第1个元素放回
以此类推，得到的栈序列即是逆序

## 004-solution
pet为宠物抽象类，用于描述待入队列的宠物
dog和cat继承自pet
而后创建一个队列petqueue，用于表示队列，队列中维护两个queue，一个dogqueue，一个catqueue，分别用于dog和cat的入队，并且维护一个count记录宠物入队的时间
在add时自动填充count并且自增，在出队时，取出队头元素对比count再出列